#!/usr/bin/env python3
#######################################################################################################################
#
# DATE: 2018-04-16
# NAME: create_event_summaries.py
# AUTHOR: Jeremy R. B. Newman (jrbnewman@ufl.edu)
#
# DESCRIPTION: This script creates an output table that summarizes introns, border junctions and adjacent exonic
# regions and classifies these events into possible novel donor/acceptor, intron retention, or unprocessed transcript,
# based on some simple rules. The input is the intron summaries, exonic region (fusion) summaries, junction summaries,
# design file, the intron-to-border junction index, and the set of expressed genes. The user also specifies how to
# classify # intron-border junction combinations. Only events from expressed genes are considered. The output is a
# table, sorted by treatment group, gene and intron.
#
# If both adjacent exonic regions are not detected, then the intron is classified as 'Unanalyzable'
# If both exonic regions are detected, but neither border junction or intron, then this is classified as 'No intron detected'
# If the donor exonic region and border junction are detected, and the mean border junction coverage is above the
# user-specified threshold, then the event is suggested as "Possible novel donor". Similarly, if the acceptor exonic
# region and acceptor junction are detected, and the mean border junction coverage is above the user-specified
# threshold, then the event is classified as "Possible novel acceptor". Events where both of these are true are
# classified as "Possible novel donor and acceptor". When the exonic regions and intron are detected, and the mean
# intron coverage is above a user-defined threshold, then the event is classfied as "Possible intron retention". Where
# one or both of the border junctions are also detected and exceed their respective user-defined thresholds, then the
# event is called as "Possible intron retention with border junctions". Where the associated events (exonic region,
# border junction and/or intron) are detected but do not meet their respective thresholds, then the suggested
# classification takes the closest classification possible
#
# REQUIRED PACKAGES: pandas    (tested with v0.19.2)
#                    argparse  (tested with v1.1)
#                    logging   (tested with v0.5.1.2)
#                    sqlite3
#
#######################################################################################################################

# Import required packages
import pandas as pd
import logging
import sqlite3
import argparse

def getOptions():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Takes exonic region, intron, and junction summaries, the intron-to-"
                                                 "border junction index and a design file and outputs a TSV of group-wise \
                                                 detection flags")
    # Inputs
    parser.add_argument("-e", "--input-exonic-region-summary", dest="inFus", required=True,
                        help="Summary of fusions/exonic regions as generated by create_event_summaries.py")
    parser.add_argument("-i", "--input-intron-summary", dest="inIntron", required=True,
                        help="Summary of introns as generated by create_event_summaries.py")
    parser.add_argument("-j", "--input-junction-summary", dest="inJunc", required=True,
                        help="Summary of junctions as generated by create_event_summaries.py")
    parser.add_argument("-I", "-x", "--intron-border-junction-index", dest="inIndex", required=True,
                        help="Index file relating introns, border junctions and exonic regions")
    parser.add_argument("-d", "--design-file", dest="inDesign", required=True,
                        help="Design file to relate samples to groups")
    # User-defined values
    parser.add_argument("-g", "--group-variable", dest="userGroup", required=True,
                        help="Variable in design file to group samples on")
    parser.add_argument("--minimum-donor-mean", dest="userDonor", required=True, type=int,
                        help="Minimum group mean for donor border junction to be considered 'likely present' ")
    parser.add_argument("--minimum-acceptor-mean", dest="userAcceptor", required=True, type=int,
                        help="Minimum group mean for acceptor border junction to be considered 'likely present' ")
    parser.add_argument("--minimum-intron-mean", dest="userIntron", required=True, type=int,
                        help="Minimum group mean for intron to be considered 'likely present' ")

    # Outputs
    parser.add_argument("-o", "--output-intron-border-summary", dest="outSummary", required=True,
                        help="Output TSV of gene-level expression flags")
    args = parser.parse_args()
    return args

def main():
    # Connect to SQL database
    con = sqlite3.connect(":memory:")
    cur = con.cursor()
    # Import data
    fusionDF = pd.read_csv(args.inFus, sep="\t")
    intronDF = pd.read_csv(args.inIntron, sep="\t")
    juncDF = pd.read_csv(args.inJunc, sep="\t")
    indexDF = pd.read_csv(args.inIndex, sep=",")
    designDF = pd.read_csv(args.inDesign, sep="\t")
    # Put data into SQL database
    fusionDF.to_sql("fusInfo", con, if_exists="replace")
    intronDF.to_sql("intronInfo", con, if_exists="replace")
    juncDF.to_sql("juncInfo", con, if_exists="replace")
    indexDF.to_sql("intronIndex", con, if_exists="replace")
    # Get list of groups to iterate over
    groupList = designDF[args.userGroup].drop_duplicates(keep='first').tolist()
    # Iterate over groups
    counter = 1
    for group in range(0,len(groupList)) :
        groupName = groupList[group]
        # Merge in intron info -> detection flags, mean APN
        cur.execute("CREATE TABLE intronTemp AS SELECT event_id as intron_id, mean_apn_"+groupName+" AS "
                    "mean_apn_intron, flag_"+groupName+"_detected AS flag_intron_detected "
                    "FROM intronInfo; ")
        cur.execute("CREATE TABLE indexI AS SELECT in1.*, in2.mean_apn_intron, in2.flag_intron_detected "
                    "FROM intronIndex in1 INNER JOIN intronTemp in2 "
                    "ON in1.intron_id = in2.intron_id ;")
        # Merge in fusion info -> detection flags, mean APN
        cur.execute("CREATE TABLE exonTemp5 AS SELECT event_id as exonic_region_id_5prime, mean_apn_"+groupName+" AS "
                    "mean_apn_5prime_exon, flag_"+groupName+"_detected AS flag_5prime_exon_detected "
                    "FROM fusInfo; ")
        cur.execute("CREATE TABLE exonTemp3 AS SELECT event_id as exonic_region_id_3prime, mean_apn_"+groupName+" AS "
                    "mean_apn_3prime_exon, flag_"+groupName+"_detected AS flag_3prime_exon_detected "
                    "FROM fusInfo; ")
        cur.execute("CREATE TABLE indexIF5 AS SELECT in1.*, in2.mean_apn_5prime_exon, in2.flag_5prime_exon_detected "
                    "FROM indexI in1 INNER JOIN exonTemp5 in2 "
                    "ON in1.exonic_region_id_5prime = in2.exonic_region_id_5prime ;")
        cur.execute("CREATE TABLE indexIF53 AS SELECT in1.*, in2.mean_apn_3prime_exon, in2.flag_3prime_exon_detected "
                    "FROM indexIF5 in1 INNER JOIN exonTemp3 in2 "
                    "ON in1.exonic_region_id_3prime = in2.exonic_region_id_3prime ;")
        # Merge in junction info -> detection flags, mean APN
        cur.execute("CREATE TABLE juncTemp5 AS SELECT event_id as border_junction_id_5prime, mean_apn_"+groupName+" AS "
                    "mean_apn_5prime_border, flag_"+groupName+"_detected AS flag_5prime_border_detected "
                    "FROM juncInfo; ")
        cur.execute("CREATE TABLE juncTemp3 AS SELECT event_id as border_junction_id_3prime, mean_apn_"+groupName+" AS "
                    "mean_apn_3prime_border, flag_"+groupName+"_detected AS flag_3prime_border_detected "
                    "FROM juncInfo; ")
        cur.execute("CREATE TABLE indexIF53J5 AS SELECT in1.*, in2.mean_apn_5prime_border, in2.flag_5prime_border_detected "
                    "FROM indexIF53 in1 INNER JOIN juncTemp5 in2 "
                    "ON in1.border_junction_id_5prime = in2.border_junction_id_5prime ;")
        cur.execute("CREATE TABLE eventSummary AS SELECT in1.*, in2.mean_apn_3prime_border, in2.flag_3prime_border_detected "
                    "FROM indexIF53J5 in1 INNER JOIN juncTemp3 in2 "
                    "ON in1.border_junction_id_3prime = in2.border_junction_id_3prime ;")
        # Flag if resolvable
        cur.execute("ALTER TABLE eventSummary ADD flag_resolvable INT;")
        cur.execute("UPDATE eventSummary SET flag_resolvable = (CASE WHEN flag_5prime_exon_detected=1 or "
                    "flag_3prime_exon_detected=1 THEN '1' ELSE '0' END) ; ")
        # Flag if possible novel donor - detection and supported
        cur.execute("ALTER TABLE eventSummary ADD flag_novel_donor_dtct INT;")
        cur.execute("ALTER TABLE eventSummary ADD flag_novel_donor_support INT;")
        cur.execute("UPDATE eventSummary SET flag_novel_donor_dtct = (CASE WHEN flag_5prime_exon_detected=1 and "
                    "flag_5prime_border_detected=1 THEN '1' ELSE '0' END) ; ")
        if args.userDonor > 0 :
            cur.execute("UPDATE eventSummary SET flag_novel_donor_support = (CASE WHEN flag_novel_donor_dtct=1 and "
                        "mean_apn_5prime_border >= ? THEN '1' ELSE '0' END) ; ", (args.userDonor, ))
        else:
            cur.execute("UPDATE eventSummary SET flag_novel_donor_support = (CASE WHEN flag_novel_donor_dtct=1 and "
                        "mean_apn_5prime_border > ? THEN '1' ELSE '0' END) ; ", (args.userDonor,))
        # Flag if possible novel acceptor - detection and supported
        cur.execute("ALTER TABLE eventSummary ADD flag_novel_acceptor_dtct INT;")
        cur.execute("ALTER TABLE eventSummary ADD flag_novel_acceptor_support INT;")
        cur.execute("UPDATE eventSummary SET flag_novel_acceptor_dtct = (CASE WHEN flag_3prime_exon_detected=1 and "
                    "flag_3prime_border_detected=1 THEN '1' ELSE '0' END) ; ")
        if args.userAcceptor > 0 :
            cur.execute("UPDATE eventSummary SET flag_novel_acceptor_support = (CASE WHEN flag_novel_donor_dtct=1 and "
                        "mean_apn_3prime_border >= ? THEN '1' ELSE '0' END) ; ", (args.userAcceptor, ))
        else:
            cur.execute("UPDATE eventSummary SET flag_novel_acceptor_support = (CASE WHEN flag_novel_donor_dtct=1 and "
                        "mean_apn_3prime_border > ? THEN '1' ELSE '0' END) ; ", (args.userAcceptor,))
        # Flag if possible IR - detection and supported
        cur.execute("ALTER TABLE eventSummary ADD flag_intron_retention_dtct INT;")
        cur.execute("ALTER TABLE eventSummary ADD flag_intron_retention_support INT;")
        cur.execute("UPDATE eventSummary SET flag_intron_retention_dtct = (CASE WHEN flag_resolvable=1 and "
                    "flag_intron_detected=1 THEN '1' ELSE '0' END) ; ")
        if args.userIntron > 0 :
            cur.execute("UPDATE eventSummary SET flag_intron_retention_support = (CASE WHEN flag_intron_retention_dtct=1 and "
                        "mean_apn_intron>= ? THEN '1' ELSE '0' END) ; ", (args.userIntron, ))
        else:
            cur.execute("UPDATE eventSummary SET flag_intron_retention_support = (CASE WHEN flag_intron_retention_dtct=1 and "
                        "mean_apn_intron > ? THEN '1' ELSE '0' END) ; ", (args.userIntron, ))
        # Classify events under 'detection' and 'supported'
        cur.execute("ALTER TABLE eventSummary ADD event_classification_detection TEXT;")
        cur.execute("ALTER TABLE eventSummary ADD event_classification_support TEXT;")
        cur.execute("UPDATE eventSummary "
                    "SET event_classification_detection = (CASE WHEN flag_resolvable = 0 THEN 'Unresolvable' "
                    "WHEN flag_novel_donor_dtct = 1 AND flag_novel_acceptor_dtct = 1 AND flag_intron_retention_dtct = 1 "
                    "THEN 'Possible intron retention (with borders)' WHEN flag_novel_donor_dtct = 1 AND "
                    "flag_novel_acceptor_dtct = 1 AND flag_intron_retention_dtct = 0 THEN "
                    "'Possible novel donor, novel acceptor' WHEN flag_novel_donor_dtct = 1 AND flag_novel_acceptor_dtct = 0 "
                    "AND flag_intron_retention_dtct = 1 THEN 'Possible intron retention (with donor border)' "
                    "WHEN flag_novel_donor_dtct = 1 AND flag_novel_acceptor_dtct = 0 AND flag_intron_retention_dtct = 0 "
                    "THEN 'Possible novel donor' WHEN flag_novel_donor_dtct = 0 AND flag_novel_acceptor_dtct = 1 AND "
                    "flag_intron_retention_dtct = 1 THEN 'Possible intron retention (with acceptor border)' WHEN "
                    "flag_novel_donor_dtct = 0 AND flag_novel_acceptor_dtct = 1 AND flag_intron_retention_dtct = 0 THEN "
                    "'Possible novel acceptor' WHEN flag_novel_donor_dtct = 0 AND flag_novel_acceptor_dtct = 0 AND "
                    "flag_intron_retention_dtct = 1 THEN 'Possible intron retention (no borders)' "
                    "ELSE 'Unprocessed mRNA/Other' END);")
        cur.execute("UPDATE eventSummary "
                    "SET event_classification_support = (CASE WHEN flag_resolvable = 0 THEN 'Unresolvable' "
                    "WHEN flag_novel_donor_support = 1 AND flag_novel_acceptor_support = 1 AND flag_intron_retention_support = 1 "
                    "THEN 'Possible intron retention (with borders)' WHEN flag_novel_donor_support = 1 AND "
                    "flag_novel_acceptor_support = 1 AND flag_intron_retention_support = 0 THEN "
                    "'Possible novel donor, novel acceptor' WHEN flag_novel_donor_support = 1 AND flag_novel_acceptor_support = 0 "
                    "AND flag_intron_retention_support = 1 THEN 'Possible intron retention (with donor border)' "
                    "WHEN flag_novel_donor_support = 1 AND flag_novel_acceptor_support = 0 AND flag_intron_retention_support = 0 "
                    "THEN 'Possible novel donor' WHEN flag_novel_donor_support = 0 AND flag_novel_acceptor_support = 1 AND "
                    "flag_intron_retention_support = 1 THEN 'Possible intron retention (with acceptor border)' WHEN "
                    "flag_novel_donor_support = 0 AND flag_novel_acceptor_support = 1 AND flag_intron_retention_support = 0 THEN "
                    "'Possible novel acceptor' WHEN flag_novel_donor_support = 0 AND flag_novel_acceptor_support = 0 AND "
                    "flag_intron_retention_support = 1 THEN 'Possible intron retention (no borders)' "
                    "ELSE 'Unprocessed mRNA/Other' END);")
        cur.execute("ALTER TABLE eventSummary ADD treatment_group TEXT ;")
        cur.execute("UPDATE eventSummary SET treatment_group = '" + groupName + "'; ")
        # Append
        if counter == 1:
            cur.execute("CREATE TABLE eventSummaryOut AS SELECT * FROM eventSummary ;")
            counter = counter + 1
        else:
            cur.execute("INSERT INTO eventSummaryOut SELECT * FROM eventSummary")
        cur.execute("DROP TABLE intronTemp;")
        cur.execute("DROP TABLE indexI;")
        cur.execute("DROP TABLE exonTemp5;")
        cur.execute("DROP TABLE indexIF5;")
        cur.execute("DROP TABLE exonTemp3;")
        cur.execute("DROP TABLE indexIF53;")
        cur.execute("DROP TABLE juncTemp5;")
        cur.execute("DROP TABLE indexIF53J5;")
        cur.execute("DROP TABLE juncTemp3;")
        cur.execute("DROP TABLE eventSummary;")

    intronSummaryDF = pd.read_sql("SELECT * FROM eventSummaryOut;", con)

    with open(args.outSummary, 'w') as outFile:
        intronSummaryDF.to_csv(outFile, encoding='utf-8', index=False, sep="\t")

if __name__ == '__main__':
    # Parse command line arguments
    global args
    args = getOptions()
    # Setting up logger
    logger = logging.getLogger()
    logger.info('Starting script')
    # Calling main script
    main()
    logger.info('Script complete')

