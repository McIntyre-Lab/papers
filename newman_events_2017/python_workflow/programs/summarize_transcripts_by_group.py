#!/usr/bin/env python3
#######################################################################################################################
#
# DATE: 2018-04-18
# NAME: summarize_transcripts_by_group.py
# AUTHOR: Jeremy R. B. Newman (jrbnewman@ufl.edu)
#
# DESCRIPTION: This script creates an output table that summarizes transcripts in terms of the number of events (exon
# fragments, junctions, total), the number of unique events, the number and proportion of events detected, the number
# and proportion of unique events detected (if any). The input is the junction summaries, exon fragment summaries,
# gene-level summaries created by identify_expressed_genes.py, the event-to-transcript index created by
# build_Event2Transcript_index.py and a design file. The output is a summary table of transcripts sorted by
# treatment group, gene ID and transcript ID. Only transcripts in genes that are considered expressed are considered.
# Transcripts are also flagged if they contain exonic regions with ambiguous genic identity (i.e. exonic regions that
# are shared by overlapping genes). The output table is designed to provide to users the means to decide what
# annotated transcripts to eliminate from their analysis, and what transcripts are likely expressed to use as a
# reference for transcript quantification algorithms, such as RSEM and eXpress.
#
# REQUIRED PACKAGES: pandas    (tested with v0.19.2)
#                    argparse  (tested with v1.1)
#                    logging   (tested with v0.5.1.2)
#                    sqlite3
#
#######################################################################################################################

# Import required packages
import pandas as pd
import logging
import sqlite3
import argparse

def getOptions():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Takes junction, fragment and gene summaries and a design file and outputs a "
                                                 "TSV summarizing transcript event detection by group")
    # Inputs
    parser.add_argument("-G", "--input-gene-summary", dest="inGene", required=True,
                        help="Summary of genes expressed generated by identify_expressed_genes.py")
    parser.add_argument("-f", "--input-exon-fragment-summary", dest="inFrag", required=True,
                        help="Summary of exon fragments as generated by create_event_summaries.py")
    parser.add_argument("-j", "--input-junction-summary", dest="inJunc", required=True,
                        help="Summary of junctions as generated by create_event_summaries.py")
    parser.add_argument("-i", "--input-event-to-transcript-index", dest="inIndex", required=True,
                        help="Event-to-transcript-to-gene index as generated by build_Event2Transcript_index.py")
    parser.add_argument("-d", "--design-file", dest="inDesign", required=True,
                        help="Design file to relate samples to groups")

    # User-defined values
    parser.add_argument("-g", "--group-variable", dest="userGroup", required=True,
                        help="Variable in design file used to group samples by treatment, condition, etc.")

    # Outputs
    parser.add_argument("-o", "--output-transcript-summary", dest="outSummary", required=True,
                        help="Output TSV of transcript-level event detection summaries")
    args = parser.parse_args()
    return args

def main():
    # Connect to SQL database
    con = sqlite3.connect(":memory:")
    cur = con.cursor()
    # Import summary data, event index and design file
    geneDF = pd.read_csv(args.inGene, sep="\t")
    fragDF = pd.read_csv(args.inFrag, sep="\t")
    juncDF = pd.read_csv(args.inJunc, sep="\t")
    designDF = pd.read_csv(args.inDesign, sep="\t")
    indexDF = pd.read_csv(args.inIndex, sep=",")

    # Put data into SQL database
    geneDF.to_sql("geneInfo", con, if_exists="replace")
    fragDF.to_sql("fragInfo", con, if_exists="replace")
    juncDF.to_sql("juncInfo", con, if_exists="replace")
    indexDF.to_sql("eventIndex", con, if_exists="replace")

    # Get list of groups to iterate over
    groupList = designDF[args.userGroup].drop_duplicates(keep='first').tolist()
    # Iterate over groups
    counter = 1
    for group in range(0,len(groupList)) :
        groupName = groupList[group]
        # Remove non-expressed genes from event index
        cur.execute("CREATE TABLE expGene AS SELECT gene_id, flag_gene_has_multigene_exon "
                    "FROM geneInfo WHERE  flag_gene_expressed_"+groupName+" = 1; ")
        cur.execute("CREATE TABLE eventIndex2 AS SELECT in1.event_id, in1.transcript_id, in1.gene_id, "
                    "in1.annotation_frequency, in2.flag_gene_has_multigene_exon "
                    "FROM eventIndex in1 INNER JOIN expGene in2 "
                    "ON in1.gene_id = in2.gene_id "
                    "WHERE transcript_id != 'Unannotated' ORDER BY event_id ;")
        # Get number of junctions, unique junctions, detected junctions and detected unique junctions per transcript
        ### Merge in junction detection flags from junction summary
        cur.execute("CREATE TABLE flagJunc AS SELECT event_id, flag_"+groupName+"_detected FROM juncInfo "
                    "WHERE flag_junction_annotated = 1 ORDER BY event_id ; ")
        cur.execute("CREATE TABLE flagJunc2Xs AS SELECT in1.*, in2.flag_"+groupName+"_detected "
                    "FROM eventIndex2 in1 INNER JOIN flagJunc in2 WHERE in1.event_id = in2.event_id ;")
        ### Count number of junctions and detected junctions
        cur.execute("CREATE TABLE countJunc AS SELECT distinct gene_id, transcript_id,"
                    "count(distinct event_id) AS num_junctions, sum(flag_"+groupName+"_detected) AS "
                    "num_detected_junctions FROM flagJunc2Xs GROUP BY gene_id, transcript_id ;")
        ### Count number of unique junctions and detected unique junctions
        cur.execute("CREATE TABLE countUniqJunc AS SELECT distinct gene_id, transcript_id,"
                    "count(distinct event_id) AS num_unique_junctions, sum(flag_"+groupName+"_detected) AS "
                    "num_detected_unique_junctions FROM flagJunc2Xs WHERE annotation_frequency='Unique' "
                    "GROUP BY gene_id, transcript_id ;")
        ### Merge
        cur.execute("CREATE TABLE juncByXs AS SELECT in1.*, in2.num_unique_junctions, "
                    "in2.num_detected_unique_junctions FROM countJunc in1 LEFT JOIN countUniqJunc in2 "
                    "ON in1.gene_id=in2.gene_id AND in1.transcript_id=in2.transcript_id ;")
        # Get number of fragments, unique fragments, detected fragments and detected unique fragments per transcript

        ### Merge in fragment detection flags from fragment summary
        cur.execute("CREATE TABLE flagFrag AS SELECT event_id, flag_"+groupName+"_detected FROM fragInfo "
                    "ORDER BY event_id ; ")
        cur.execute("CREATE TABLE flagFrag2Xs AS SELECT in1.*, in2.flag_"+groupName+"_detected "
                    "FROM eventIndex2 in1 INNER JOIN flagFrag in2 WHERE in1.event_id = in2.event_id ;")
        ### Count number of fragments and detected fragments
        cur.execute("CREATE TABLE countFrag AS SELECT distinct gene_id, transcript_id, flag_gene_has_multigene_exon, "
                    "count(distinct event_id) AS num_fragments, sum(flag_"+groupName+"_detected) AS "
                    "num_detected_fragments FROM flagFrag2Xs GROUP BY gene_id, transcript_id ;")
        ### Count number of unique fragments and detected unique fragments
        cur.execute("CREATE TABLE countUniqFrag AS SELECT distinct gene_id, transcript_id,"
                    "count(distinct event_id) AS num_unique_fragments, sum(flag_"+groupName+"_detected) AS "
                    "num_detected_unique_fragments FROM flagFrag2Xs WHERE annotation_frequency='Unique' "
                    "GROUP BY gene_id, transcript_id ;")
        ### Merge
        cur.execute("CREATE TABLE fragByXs AS SELECT in1.*, in2.num_unique_fragments, "
                    "in2.num_detected_unique_fragments FROM countFrag in1 LEFT JOIN countUniqFrag in2 "
                    "ON in1.gene_id=in2.gene_id AND in1.transcript_id=in2.transcript_id ;")
        # Merge together, count total events for each
        ### Merge junction and fragment counts
        cur.execute("CREATE TABLE eventByXs AS SELECT in1.*, in2.num_junctions, in2.num_detected_junctions, "
                    "in2.num_unique_junctions, in2.num_detected_unique_junctions "
                    "FROM fragByXs in1 LEFT JOIN juncByXs in2 "
                    "ON in1.gene_id=in2.gene_id AND in1.transcript_id=in2.transcript_id ;")
        cur.execute("UPDATE eventByXs SET num_fragments = 0 WHERE coalesce(num_fragments, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_detected_fragments = 0 WHERE coalesce(num_detected_fragments, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_unique_fragments = 0 WHERE coalesce(num_unique_fragments, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_detected_unique_fragments = 0 WHERE coalesce(num_detected_unique_fragments, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_junctions = 0 WHERE coalesce(num_junctions, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_unique_junctions = 0 WHERE coalesce(num_unique_junctions, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_detected_junctions = 0 WHERE coalesce(num_detected_junctions, '') = '' ;")
        cur.execute("UPDATE eventByXs SET num_detected_unique_junctions = 0 WHERE coalesce(num_detected_unique_junctions, '') = '' ;")
        ### Sum events, and calculate proportions
        cur.execute("ALTER TABLE eventByXs ADD perc_fragments_detected ;")
        cur.execute("UPDATE eventByXs SET perc_fragments_detected = num_detected_fragments / (num_fragments * 1.0000) * 100 "
                    "WHERE num_fragments > 0;")
        cur.execute("ALTER TABLE eventByXs ADD perc_unique_fragments_detected  ;")
        cur.execute("UPDATE eventByXs SET perc_unique_fragments_detected = num_detected_unique_fragments / "
                    "(num_unique_fragments * 1.0000) * 100 WHERE num_unique_fragments > 0;")
        cur.execute("ALTER TABLE eventByXs ADD perc_junctions_detected ;")
        cur.execute("UPDATE eventByXs SET perc_junctions_detected = num_detected_junctions / (num_junctions * 1.0000) * 100 "
                    "WHERE num_junctions > 0;")
        cur.execute("ALTER TABLE eventByXs ADD perc_unique_junctions_detected   ;")
        cur.execute("UPDATE eventByXs SET perc_unique_junctions_detected = num_detected_unique_junctions / "
                    "(num_unique_junctions * 1.0000) * 100 WHERE num_unique_junctions > 0;")
        cur.execute("ALTER TABLE eventByXs ADD num_events INT ;")
        cur.execute("UPDATE eventByXs SET num_events = num_junctions + num_fragments; ")
        cur.execute("ALTER TABLE eventByXs ADD num_unique_events INT ;")
        cur.execute("UPDATE eventByXs SET num_unique_events = num_unique_junctions + num_unique_fragments; ")
        cur.execute("ALTER TABLE eventByXs ADD num_detected_events INT ;")
        cur.execute("UPDATE eventByXs SET num_detected_events = num_detected_junctions + num_detected_fragments; ")
        cur.execute("ALTER TABLE eventByXs ADD num_detected_unique_events INT ;")
        cur.execute("UPDATE eventByXs SET num_detected_unique_events = num_detected_unique_junctions + "
                    "num_detected_unique_fragments; ")
        cur.execute("ALTER TABLE eventByXs ADD perc_events_detected ;")
        cur.execute("UPDATE eventByXs SET perc_events_detected = num_detected_events / (num_events * 1.0000) * 100 "
                    "WHERE num_events > 0;")
        cur.execute("ALTER TABLE eventByXs ADD perc_unique_events_detected  ;")
        cur.execute("UPDATE eventByXs SET perc_unique_events_detected = num_detected_unique_events / "
                    "(num_unique_events * 1.0000) * 100 WHERE num_unique_events > 0;")
        cur.execute("ALTER TABLE eventByXs ADD treatment_group TEXT ;")
        cur.execute("UPDATE eventByXs SET treatment_group = '"+ groupName +"'; ")

        # Append
        if counter == 1 :
            cur.execute("CREATE TABLE xscriptSummary AS SELECT * FROM eventByXs ;")
            counter = counter + 1
        else :
            cur.execute("INSERT INTO xscriptSummary SELECT * FROM eventByXs")
        cur.execute("DROP TABLE expGene;")
        cur.execute("DROP TABLE eventIndex2;")
        cur.execute("DROP TABLE flagJunc;")
        cur.execute("DROP TABLE flagJunc2Xs;")
        cur.execute("DROP TABLE countJunc;")
        cur.execute("DROP TABLE countUniqJunc;")
        cur.execute("DROP TABLE juncByXs;")
        cur.execute("DROP TABLE flagFrag;")
        cur.execute("DROP TABLE flagFrag2Xs;")
        cur.execute("DROP TABLE countFrag;")
        cur.execute("DROP TABLE countUniqFrag;")
        cur.execute("DROP TABLE fragByXs;")
        cur.execute("DROP TABLE eventByXs;")

    # Write output summary file
    xscriptSummaryDF = pd.read_sql("SELECT * FROM xscriptSummary ORDER BY gene_id, transcript_id, treatment_group;", con)
    xscriptSummaryDF=xscriptSummaryDF[['gene_id','transcript_id','treatment_group','flag_gene_has_multigene_exon',
                                       'num_fragments','num_detected_fragments','perc_fragments_detected',
                                       'num_unique_fragments','num_detected_unique_fragments',
                                       'perc_unique_fragments_detected','num_junctions','num_detected_junctions',
                                       'perc_junctions_detected','num_unique_junctions','num_detected_unique_junctions',
                                       'perc_unique_junctions_detected','num_events','num_detected_events',
                                       'perc_events_detected','num_unique_events','num_detected_unique_events',
                                       'perc_unique_events_detected']]
    with open(args.outSummary, 'w') as outFile:
        xscriptSummaryDF.to_csv(outFile, encoding='utf-8', index=False, sep="\t")

if __name__ == '__main__':
    # Parse command line arguments
    global args
    args = getOptions()
    # Setting up logger
    logger = logging.getLogger()
    logger.info('Starting script')
    # Calling main script
    main()
    logger.info('Script complete')


