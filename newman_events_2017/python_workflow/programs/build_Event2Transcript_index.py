#!/usr/bin/env python3
#######################################################################################################################
#
# DATE: 2017-12-15
# NAME: build_Event2Transcript_index.py
# AUTHOR: Jeremy R. B. Newman (jrbnewman@ufl.edu)
#
# DESCRIPTION: This script creates an event-to-transcript-to-gene index file used by Event Analysis to determine
# the proportion of events detected per transcript. It takes the previously-generated annotation CSVs for exons
# (generated by extract_Exons.py), exon fragments, and junctions, assigns fragments to transcripts and genes, and
# outputs a complete event index file. If events are assigned to multiple transcripts or genes, then each assignment
# for that event is output (the unique key is the combination of event, transcript and gene). If an event is assigned
# to only a single transcript, then the binary indicator variable 'flag_unique' is set to '1', else if the event has
# multiple assignments then flag_unique is set to '0'. If an event has no transcript assignments (i.e. unannotated
# junctions and border junctions, then the transcript is assigned as 'Unannotated' and 'flag_unique' is left blank
#
# REQUIRED PACKAGES: pandas    (tested with v0.19.2)
#                    argparse  (tested with v1.1)
#                    logging   (tested with v0.5.1.2)
#
#######################################################################################################################

# Import required packages
import pandas as pd
import logging
import sqlite3
import argparse

def getOptions():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate an event-to-transcript-gene index file for"
                                                 "determining possible set of transcripts, and transcripts"
                                                 "that are not likely expressed")
    parser.add_argument("-e", "--exon-info", dest="inExons", required=True, help="Input exon annotation CSV")
    parser.add_argument("-f", "--fragment-info", dest="inFragments", required=True,
                        help="Input exon fragment annotation CSV")
    parser.add_argument("-j", "--junction-info", dest="inJunctions", required=True,
                        help="Input junction annotation CSV")
    parser.add_argument("-o", "--output", dest="outCSV", required=True,
                        help="Output event index CSV")
    args = parser.parse_args()
    return args

def main():
    # Connect to database
    con = sqlite3.connect(":memory:")
    cur = con.cursor()
    # Import exon, fragment and junction annotations
    logger.info("Importing exon, fragment and junction annotations")
    # From exon information, get set of transcripts and genes
    xs2geneDF = pd.read_csv(args.inExons, usecols=('transcript_id','gene_id'))
    # From fragment annotations, get IDs, transcripts, frequency and flag_multigene
    fragDF = pd.read_csv(args.inFragments, usecols=('fragment_id','transcript_id','annotation_frequency','flag_multigene'))
    # From junction annotations, get IDs, transcripts, genes, frequency and flag_multigene
    # Genes only need for unannotated events
    juncDF = pd.read_csv(args.inJunctions, usecols=('junction_id','transcript_id','gene_id','annotation_frequency','flag_multigene'))
    # Convert dataframes to SQL databases
    xs2geneDF.to_sql("xs2gene", con, if_exists="replace")
    fragDF.to_sql("fragInfo", con, if_exists="replace")
    juncDF.to_sql("juncInfo", con, if_exists="replace")
    # Create a unique transcript-to-gene index
    cur.execute("SELECT distinct transcript_id, gene_id FROM xs2gene ;")
    allxs2genes= cur.fetchall()
    cur.execute("CREATE TABLE IF NOT EXISTS xs2geneIndex (transcript_id TEXT, gene_id TEXT);")
    for row in allxs2genes:
        xscripts = row[0].split("|")
        for xs in xscripts:
            cur.execute("INSERT INTO xs2geneIndex VALUES(:transcript_id, :gene_id ) ;",
                        {"transcript_id": xs, "gene_id": row[1] })
    cur.execute("CREATE TABLE xs2geneIndex2 AS SELECT distinct transcript_id, gene_id FROM xs2geneIndex ;")
    # First split events into annotated (fragments, junctions) and unannotated (junctions). Fragments can't be unannotated
    cur.execute("CREATE TABLE annotIndex AS SELECT fragment_id AS event_id, transcript_id, annotation_frequency, "
                "flag_multigene FROM fragInfo ;")
    cur.execute("CREATE TABLE annotJunc AS SELECT junction_id AS event_id, transcript_id, annotation_frequency, "
                "flag_multigene FROM juncInfo WHERE annotation_frequency != 'Unannotated' ")
    cur.execute("CREATE TABLE unannotJunc AS SELECT junction_id AS event_id, transcript_id, gene_id, annotation_frequency, "
                "flag_multigene FROM juncInfo WHERE annotation_frequency = 'Unannotated' ")
    # Stack fragments and annotated junctions
    cur.execute("INSERT INTO annotIndex(event_id, transcript_id, annotation_frequency, flag_multigene) "
                "SELECT event_id, transcript_id, annotation_frequency, flag_multigene "
                "FROM annotJunc ; ")
    # De-concatenate transcripts
    cur.execute("Select distinct event_id, transcript_id, annotation_frequency, flag_multigene FROM annotIndex "
                "ORDER BY event_id ; ")
    allxs2event= cur.fetchall()
    cur.execute("CREATE TABLE IF NOT EXISTS annotIndex2 (event_id TEXT, transcript_id TEXT, annotation_frequency TEXT, "
                "flag_multigene INT);")
    for event in allxs2event:
        xscripts = event[1].split("|")
        for xs in xscripts:
            cur.execute("INSERT INTO annotIndex2 VALUES(:event_id, :transcript_id, :annotation_frequency, "
                        ":flag_multigene) ;", {"event_id": event[0], "transcript_id": xs, "annotation_frequency": event[2],
                                               "flag_multigene": event[3] })
    # Join gene IDs onto transcripts
    cur.execute("CREATE TABLE annotIndex3 AS SELECT in1.*, in2.gene_id "
                "FROM annotIndex2 in1 INNER JOIN xs2geneIndex2 in2 "
                "ON in1.transcript_id = in2.transcript_id ;")
    # Append unannotated junctions
    cur.execute("INSERT INTO annotIndex3(event_id, transcript_id, annotation_frequency, flag_multigene, gene_id) "
                "SELECT event_id, transcript_id, annotation_frequency, flag_multigene, gene_id "
                "FROM unannotJunc ; ")
    # Write output

    event2xsIndexDF = pd.read_sql("SELECT event_id, transcript_id, gene_id, annotation_frequency, flag_multigene "
                                  " FROM annotIndex3 ;", con)
    event2xsIndexDF=event2xsIndexDF[['event_id','transcript_id','gene_id','annotation_frequency','flag_multigene']]

    # Write output index
    with open(args.outCSV, 'w') as outIndex:
        event2xsIndexDF.to_csv(outIndex, encoding='utf-8', index=False)

if __name__ == '__main__':
    # Parse command line arguments
    global args
    args = getOptions()

    # Setting up logger
    logger = logging.getLogger()
    logger.info('Starting script')

    # Calling main script
    main()
    logger.info('Script complete: index created!')


