#!/usr/bin/env python
# Built-in packages
import argparse
from argparse import RawDescriptionHelpFormatter
import logging
import sys
from collections import defaultdict

# Add-on packages

# McLab packages
import mclib
import mclib.vcf2 as mcvcf

def getOptions():
    """ Function to pull in arguments """
    description = """ """
    parser = argparse.ArgumentParser(description=description, formatter_class=RawDescriptionHelpFormatter)

    group1 = parser.add_argument_group(description="Input Files")
    group1.add_argument("--vcf", dest="vname", nargs='+', action='store', required=True, help="A list of VCF files for coutning ALTs. If not zipped using bgzip will try to create zip. [Required]")
    group1.add_argument("--cnts", dest="cname", nargs='+', action='store', required=True, help="A list of CSV files, for a given genotype, with coverage counts for RNA alignments. [Required]")

    group2 = parser.add_argument_group(description="Output Files")
    group2.add_argument("-o", dest="oname", action='store', default=sys.stdout, required=True, help="Name of output CSV file. [Required]")
    group2.add_argument("--log", dest="log", action='store', required=False, help="Name of the LOG file [Optional]") 

    parser.add_argument("--debug", dest="debug", action='store_true', required=False, help="Enable debug output.") 
    args = parser.parse_args()
    return(args)

def importCounts(cnts, fname):
    """ Import coverage counts file created by count_snps_indels.py. If
    multiple files are given, combine them into single counts. 

    Arguments:
    ----------
    fname (list) = names of count files generated by count_snps_indels.py
    cnts (dict) = a dictionary of positions with information about snps/indels
    """
    with open(fname, 'r') as FH:
        FH.next()
        for line in FH:
            chrom, pos, ref, alt, totCnt, refCnt, altCnt, flagIndel = line.rstrip().split(',')
            pos = int(pos)

            if not cnts[chrom][pos]:
                # If this position has not been counted initilize values
                cnts[chrom][pos]['ref'] = ref
                cnts[chrom][pos]['refCnt'] = int(refCnt)

                cnts[chrom][pos]['alt'] = dict()

                cnts[chrom][pos]['totalCnt'] = int(totCnt)
                cnts[chrom][pos]['flagIndel'] = int(flagIndel)

                # Initlize ALT counters
                cnts[chrom][pos]['alt']= defaultdict(int)
            else:
                # If the position has already been counted, increament
                cnts[chrom][pos]['refCnt'] += int(refCnt)
                cnts[chrom][pos]['totalCnt'] += int(totCnt)

            # Iterate over alternative alleles and add counts
            alleleCnts = altCnt.split('|')
            for index, allele in enumerate(alt.split('|')):
                cnts[chrom][pos]['alt'][allele] += int(alleleCnts[index])
    return cnts

def pullVariants(variants, fname):
    """ Create a dictionary of variants """
    myVcf = mcvcf.Vcf(fname)
    for record in myVcf.vcf_reader:
        # Keep only records that are homozygous for ALT
        if record.get_hom_alts():
            ref = record.REF
            alt = str(record.ALT[0])
            dnaCnt = record.samples[0]['DP']
            variants[record.CHROM][record.POS].add((ref, alt, dnaCnt))

            if len(record.ALT) > 1:
                logger.warn('Multiple alternative alleles detected: %s' % record.ALT)

def pullRnaCnts(cnts, chrom, pos):
    """ Pull out the useful bits from the RNA counts from Masked alignments """
    if cnts[chrom][pos]:
        totRna = cnts[chrom][pos]['totalCnt']
        refRna = cnts[chrom][pos]['refCnt']
        altRna = cnts[chrom][pos]['alt']
    else:
        totRna = 0
        refRna = 0
        altRna = 0
    return totRna, refRna, altRna

def main(args):
    ################################################################################
    # Import Coverage Counts 
    ################################################################################
    # Create dictionary key1 = chrom, key2 = pos, key3 = [ref, refCnt, alt,
    # totalCnt, flagIndel] with various values
    cnts = defaultdict(lambda: defaultdict(dict))
    for fname in args.cname:
        logger.info('Reading counts file: %s' % fname)
        cnts = importCounts(cnts, fname)

    ################################################################################
    # Import VCF File 
    ################################################################################
    # Create dictionary key1 = chrom, key2 = pos, value = list of vcf records
    variants = defaultdict(lambda: defaultdict(set))
    for index, fname in enumerate(args.vname):
        logger.info('Reading variant file: %s' % fname)
        pullVariants(variants, fname)

    ################################################################################
    # Summarize RNA/DNA counts 
    ################################################################################
    logger.info('Writing output to: %s' % args.oname)
    with open(args.oname, 'w') as OUT:
        header = ['chrom', 'pos', 'ref', 'alt', 'dnaCnt', 'altRnaCnt', 'refRnaCnt', 'totRnaCnt']
        OUT.write(','.join(header) + '\n')

        logger.info('Processing counts')

        for chrom in variants:
            for pos in variants[chrom]:
                # Grab RNA counts from the masked alignments
                totRNA, refRNA, altRNA = pullRnaCnts(cnts, chrom, pos)

                # For each ALT allele at a given position, determine if they
                # have RNA support
                for record in variants[chrom][pos]:
                    refBase, altBase, dnaCnt = record
                    try:
                        rnaCnt = altRNA[altBase]
                    except:
                        rnaCnt = 0

                    myout = [chrom, pos, refBase, altBase, dnaCnt, rnaCnt, refRNA, totRNA]
                    OUT.write(','.join(str(x) for x in myout) + '\n')



if __name__ == '__main__':
    # Turn on Logging if option -g was given
    args = getOptions()

    # Turn on logging
    logger = logging.getLogger()
    if args.debug:
        mclib.logger.setLogger(logger, args.log, 'debug')
    else:
        mclib.logger.setLogger(logger, args.log)

    # Run Main part of the script
    main(args)
    logger.info("Script complete.")
